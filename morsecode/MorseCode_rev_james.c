#pragma config(Sensor, dgtl1,  button,         sensorTouch)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Michael Wallace MtSAC
//Copyright (c) 2014 ICRL
//See the file license.txt for copying permission.

// Small changes by James Pearman 7-Oct-2014
//

#define DEBUG 1


typedef enum _beepType {
    invalid = 0,
    click,
    hold,
} beepType;

// These don't really need to be static :)
static  int  letterIndex = 0;
static  int  beepCount = 0;
static  bool newWord = true;
static string message = "";


#ifdef DEBUG
int shortBeep = 0;
int longBeep = 0;
#endif

const short UNITS_TIME_MS = 60;

/*
The word PARIS is the standard to determine CW code speed. Each dit is one element,
each dah is three elements, intra-character spacing is one element, inter-character
spacing is three elements and inter-word spacing is seven elements.
The word PARIS is exactly 50 elements.
*/

// In this version we slow down the timing to make it easier for beginners
// using the VEX touch switch
const short SHORT_BEEP   = 1;
const short LONG_BEEP    = 3;
//const short WORD_SPACE   = 3;
const short WORD_SPACE   = 4;
//const short WORD_NEW     = 7;
const short WORD_NEW     = 8;

beepType currentLetter[30];

int const LETTER_INDEX_SIZE = 30;

//get letter from morse code
char getLetter();
void shortClick();
void longClick();
void clearCurrentLetter(int size);
void updateLcdDisplay(void);

//[Y][X]
const beepType MORSE[26][4] =
{
    /*A*/{click, hold, invalid, invalid},
    /*B*/{hold, click, click, click},
    /*C*/{hold, click, hold, click},
    /*D*/{hold, click, click, invalid},
    /*E*/{click, invalid, invalid, invalid},
    /*F*/{click, click, hold, click},
    /*G*/{hold, hold, click, invalid},
    /*H*/{click, click, click, click},
    /*I*/{click, click, invalid, invalid},
    /*J*/{click, hold, hold, hold},
    /*K*/{hold, click, hold, invalid},
    /*L*/{click, hold, click, click},
    /*M*/{hold, hold, invalid, invalid},
    /*N*/{hold, click, invalid, invalid},
    /*O*/{hold, hold, hold, invalid},
    /*P*/{click, hold, hold, click},
    /*Q*/{hold, hold, click, hold},
    /*R*/{click, hold ,click, invalid},
    /*S*/{click, click, click, invalid},
    /*T*/{hold, invalid, invalid, invalid},
    /*U*/{click, click, hold, invalid},
    /*V*/{click, click, click, hold},
    /*W*/{click, hold, hold, invalid},
    /*X*/{hold, click, click, hold},
    /*Y*/{hold, click, hold, hold},
    /*Z*/{hold, hold, click, click}
};

char key[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
              'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
              'Y', 'Z', '?'};

task main()
{

    //clear letter
    clearCurrentLetter(LETTER_INDEX_SIZE);
    letterIndex = 0;
    //clear timer
    clearTimer(T1);

    while(true)//main loop
        {
        //if not a new word and button is not clicked
        if(!newWord || SensorValue(button) == 1)
            {
            newWord = false;

            //check if clicked
            if(SensorValue(button) == 1)
                {
                //is it short click or small click?
                wait1Msec(UNITS_TIME_MS * SHORT_BEEP);
                if(SensorValue(button) != 1)//short click
                    {
                    shortClick();
                    }
                else
                    {
                    wait1Msec(UNITS_TIME_MS * (LONG_BEEP - SHORT_BEEP));
                    if(SensorValue[ button ] == 1)
                        {
                        while(SensorValue[ button ] == 1)
                            wait1Msec(2);

                        longClick();

                        // Touch sensor takes some time to release
                        // so add a little more delay
                        wait1Msec(2 * UNITS_TIME_MS);
                        }
                    else//false alarm just short click
                        {
                        shortClick();
                        }
                    }
                wait1Msec(UNITS_TIME_MS);
                letterIndex++;//incremenet index
                clearTimer(T1);

                updateLcdDisplay();
                }
            else
            if((currentLetter[0] != invalid) && (time1[T1] > (UNITS_TIME_MS * WORD_SPACE)))
                {
                // clear message at 16 chars
                if( strlen(message) >= 16 )
                    message = "";

                message = message + getLetter();
                writeDebugStream("%c", getLetter());
                clearCurrentLetter(LETTER_INDEX_SIZE);
                letterIndex = 0;
                clearTimer(T1);
                updateLcdDisplay();
                }
            //check if new word
            if(!newWord && time1[T1] > (UNITS_TIME_MS * WORD_NEW))
                {
                newWord = true;
                message = message + ' ';
                writeDebugStreamLine("");
                clearTimer(T1);
                updateLcdDisplay();
                }
            }

        wait1Msec(5);
        }//end of main loop
}


//check for matching letter in Morse code grid
char getLetter()
{
    int index = 0;
    bool match = false;
    bool found = false;
    int const MAX = 26;


    while(!found && index < MAX)
        {
        match = true;
        for(int x = 0; x < 4; x++)
            {
            if(currentLetter[x] != MORSE[index][x])
                match = false;
            }
        //if match is still true then its a valid letter else increment
        if(match == true)
            found = true;
        else
            index++;
        }

    shortBeep = 0;
    longBeep  = 0;

    return key[index];
}

//short beep / click
void shortClick()
{
    // bounds check
    if( letterIndex > 3 )
        return;

#ifdef DEBUG    //short beep
    shortBeep++;
    playImmediateTone( 1000, 6 );
#endif
    clearTimer(T1);
    currentLetter[letterIndex] = click;
    beepCount++;
}


//long beep / click
void longClick()
{
    // bounds check
    if( letterIndex > 3 )
        return;

#ifdef DEBUG
    longBeep++;
    playImmediateTone( 500, 6 );
#endif
    clearTimer(T1);
    currentLetter[letterIndex] = hold;
    beepCount++;
}

//clear current letter
void clearCurrentLetter(int size)
{
    for(int x = 0; x < size; x++)
        currentLetter[x] = invalid;
}

// Display the detected input and message on the LCD
// added by James.
void updateLcdDisplay()
{
    char    line1[16];

    bLCDBacklight = true;

    line1[0] = 0;

    // Top line shows "dits" and "dahs"
    for( int i=0;i<4;i++)
        {
        if( currentLetter[i] == click )
            strcat( line1, "dit " );
        else
        if( currentLetter[i] == hold )
            strcat( line1, "dah " );
        else
            strcat( line1, "    " );
        }

    clearLCDLine( 0 );
    clearLCDLine( 1 );
    displayLCDString( 0, 0, line1 );
    displayLCDString( 1, 0, message );
}
